// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.2 effective-5.10 (swiftlang-6.0.2.1.2 clang-1600.0.26.4)
// swift-module-flags: -target arm64-apple-ios9.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -enable-bare-slash-regex -module-name Lottie
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
import CoreGraphics
import CoreText
import Foundation
@_exported import Lottie
import QuartzCore
import Swift
import UIKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency final public class AnimatedButton : Lottie.AnimatedControl {
  @_Concurrency.MainActor @preconcurrency final public func setPlayRange(fromProgress: Lottie.AnimationProgressTime, toProgress: Lottie.AnimationProgressTime, event: UIKit.UIControl.Event)
  @_Concurrency.MainActor @preconcurrency final public func setPlayRange(fromMarker fromName: Swift.String, toMarker toName: Swift.String, event: UIKit.UIControl.Event)
  @_Concurrency.MainActor @preconcurrency override public init(animation: Lottie.Animation)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init()
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override final public func beginTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override final public func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  @objc deinit
}
@objc @_Concurrency.MainActor @preconcurrency open class AnimatedControl : UIKit.UIControl {
  @_Concurrency.MainActor @preconcurrency final public let animationView: Lottie.AnimationView
  @_Concurrency.MainActor @preconcurrency public var animation: Lottie.Animation? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var animationSpeed: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public func setLayer(named: Swift.String, forState: UIKit.UIControl.State)
  @_Concurrency.MainActor @preconcurrency public func setValueProvider(_ valueProvider: any Lottie.AnyValueProvider, keypath: Lottie.AnimationKeypath)
  @_Concurrency.MainActor @preconcurrency public init(animation: Lottie.Animation)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public init()
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isSelected: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isHighlighted: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func beginTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func continueTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func cancelTracking(with event: UIKit.UIEvent?)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency open func animationDidSet()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency final public class AnimatedSwitch : Lottie.AnimatedControl {
  public enum CancelBehavior {
    case reverse
    case none
    public static func == (a: Lottie.AnimatedSwitch.CancelBehavior, b: Lottie.AnimatedSwitch.CancelBehavior) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency final public var isOn: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var cancelBehavior: Lottie.AnimatedSwitch.CancelBehavior
  @_Concurrency.MainActor @preconcurrency final public func setIsOn(_ isOn: Swift.Bool, animated: Swift.Bool, shouldFireHaptics: Swift.Bool = true)
  @_Concurrency.MainActor @preconcurrency final public func setProgressForState(fromProgress: Lottie.AnimationProgressTime, toProgress: Lottie.AnimationProgressTime, forOnState: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency override public init(animation: Lottie.Animation)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init()
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override final public func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor @preconcurrency override final public func animationDidSet()
  @objc deinit
}
public enum CoordinateSpace : Swift.Int, Swift.Codable {
  case type2d
  case type3d
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
final public class Animation : Swift.Codable {
  final public let startFrame: Lottie.AnimationFrameTime
  final public let endFrame: Lottie.AnimationFrameTime
  final public let framerate: Swift.Double
  final public var markerNames: [Swift.String] {
    get
  }
  required public init(from decoder: any Swift.Decoder) throws
  @objc deinit
  final public func encode(to encoder: any Swift.Encoder) throws
}
public protocol AnimationCacheProvider {
  func animation(forKey: Swift.String) -> Lottie.Animation?
  func setAnimation(_ animation: Lottie.Animation, forKey: Swift.String)
  func clearCache()
}
public typealias LottieCompletionBlock = (Swift.Bool) -> Swift.Void
public protocol AnimationFontProvider {
  func fontFor(family: Swift.String, size: CoreFoundation.CGFloat) -> CoreText.CTFont?
}
final public class DefaultFontProvider : Lottie.AnimationFontProvider {
  final public func fontFor(family: Swift.String, size: CoreFoundation.CGFloat) -> CoreText.CTFont?
  public init()
  @objc deinit
}
public protocol AnimationImageProvider {
  func imageForAsset(asset: Lottie.ImageAsset) -> CoreGraphics.CGImage?
}
public struct AnimationKeypath {
  public init(keypath: Swift.String)
  public init(keys: [Swift.String])
}
extension Lottie.Animation {
  public static func named(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, animationCache: (any Lottie.AnimationCacheProvider)? = nil) -> Lottie.Animation?
  public static func filepath(_ filepath: Swift.String, animationCache: (any Lottie.AnimationCacheProvider)? = nil) -> Lottie.Animation?
  public typealias DownloadClosure = (Lottie.Animation?) -> Swift.Void
  public static func loadedFrom(url: Foundation.URL, closure: @escaping Lottie.Animation.DownloadClosure, animationCache: (any Lottie.AnimationCacheProvider)?)
  final public func progressTime(forMarker named: Swift.String) -> Lottie.AnimationProgressTime?
  final public func frameTime(forMarker named: Swift.String) -> Lottie.AnimationFrameTime?
  final public func progressTime(forFrame frameTime: Lottie.AnimationFrameTime) -> Lottie.AnimationProgressTime
  final public func frameTime(forProgress progressTime: Lottie.AnimationProgressTime) -> Lottie.AnimationFrameTime
  final public func time(forFrame frameTime: Lottie.AnimationFrameTime) -> Foundation.TimeInterval
  final public func frameTime(forTime time: Foundation.TimeInterval) -> Lottie.AnimationFrameTime
  final public var duration: Foundation.TimeInterval {
    get
  }
  final public var bounds: CoreFoundation.CGRect {
    get
  }
  final public var size: CoreFoundation.CGSize {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency final public class AnimationSubview : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public protocol AnimationTextProvider : AnyObject {
  func textFor(keypathName: Swift.String, sourceText: Swift.String) -> Swift.String
}
final public class DictionaryTextProvider : Lottie.AnimationTextProvider {
  public init(_ values: [Swift.String : Swift.String])
  final public func textFor(keypathName: Swift.String, sourceText: Swift.String) -> Swift.String
  @objc deinit
}
final public class DefaultTextProvider : Lottie.AnimationTextProvider {
  final public func textFor(keypathName: Swift.String, sourceText: Swift.String) -> Swift.String
  public init()
  @objc deinit
}
public typealias AnimationFrameTime = CoreFoundation.CGFloat
public typealias AnimationProgressTime = CoreFoundation.CGFloat
public enum LottieBackgroundBehavior {
  case stop
  case pause
  case pauseAndRestore
  case forceFinish
  public static func == (a: Lottie.LottieBackgroundBehavior, b: Lottie.LottieBackgroundBehavior) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum LottieLoopMode {
  case playOnce
  case loop
  case autoReverse
  case `repeat`(Swift.Float)
  case repeatBackwards(Swift.Float)
}
extension Lottie.LottieLoopMode : Swift.Equatable {
  public static func == (lhs: Lottie.LottieLoopMode, rhs: Lottie.LottieLoopMode) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @IBDesignable @_Concurrency.MainActor @preconcurrency final public class AnimationView : Lottie.LottieView {
  @_Concurrency.MainActor @preconcurrency final public var animation: Lottie.Animation? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var backgroundBehavior: Lottie.LottieBackgroundBehavior
  @_Concurrency.MainActor @preconcurrency final public var imageProvider: any Lottie.AnimationImageProvider {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var textProvider: any Lottie.AnimationTextProvider {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var fontProvider: any Lottie.AnimationFontProvider {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var isAnimationPlaying: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency final public var isAnimationQueued: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency final public var loopMode: Lottie.LottieLoopMode {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var shouldRasterizeWhenIdle: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var currentProgress: Lottie.AnimationProgressTime {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var currentTime: Foundation.TimeInterval {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var currentFrame: Lottie.AnimationFrameTime {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var realtimeAnimationFrame: Lottie.AnimationFrameTime {
    get
  }
  @_Concurrency.MainActor @preconcurrency final public var realtimeAnimationProgress: Lottie.AnimationProgressTime {
    get
  }
  @_Concurrency.MainActor @preconcurrency final public var animationSpeed: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var respectAnimationFrameRate: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var viewportFrame: CoreFoundation.CGRect? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public func play(completion: Lottie.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency final public func play(fromProgress: Lottie.AnimationProgressTime? = nil, toProgress: Lottie.AnimationProgressTime, loopMode: Lottie.LottieLoopMode? = nil, completion: Lottie.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency final public func play(fromFrame: Lottie.AnimationFrameTime? = nil, toFrame: Lottie.AnimationFrameTime, loopMode: Lottie.LottieLoopMode? = nil, completion: Lottie.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency final public func play(fromMarker: Swift.String? = nil, toMarker: Swift.String, loopMode: Lottie.LottieLoopMode? = nil, completion: Lottie.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency final public func stop()
  @_Concurrency.MainActor @preconcurrency final public func pause()
  @_Concurrency.MainActor @preconcurrency final public func reloadImages()
  @_Concurrency.MainActor @preconcurrency final public func forceDisplayUpdate()
  @_Concurrency.MainActor @preconcurrency final public func setValueProvider(_ valueProvider: any Lottie.AnyValueProvider, keypath: Lottie.AnimationKeypath)
  @_Concurrency.MainActor @preconcurrency final public func getValue(for keypath: Lottie.AnimationKeypath, atFrame: Lottie.AnimationFrameTime?) -> Any?
  @_Concurrency.MainActor @preconcurrency final public func logHierarchyKeypaths()
  @_Concurrency.MainActor @preconcurrency final public func addSubview(_ subview: Lottie.AnimationSubview, forLayerAt keypath: Lottie.AnimationKeypath)
  @_Concurrency.MainActor @preconcurrency final public func convert(_ rect: CoreFoundation.CGRect, toLayerAt keypath: Lottie.AnimationKeypath?) -> CoreFoundation.CGRect?
  @_Concurrency.MainActor @preconcurrency final public func convert(_ point: CoreFoundation.CGPoint, toLayerAt keypath: Lottie.AnimationKeypath?) -> CoreFoundation.CGPoint?
  @_Concurrency.MainActor @preconcurrency final public func setNodeIsEnabled(isEnabled: Swift.Bool, keypath: Lottie.AnimationKeypath)
  @_Concurrency.MainActor @preconcurrency final public func progressTime(forMarker named: Swift.String) -> Lottie.AnimationProgressTime?
  @_Concurrency.MainActor @preconcurrency final public func frameTime(forMarker named: Swift.String) -> Lottie.AnimationFrameTime?
  @_Concurrency.MainActor @preconcurrency public init(animation: Lottie.Animation?, imageProvider: (any Lottie.AnimationImageProvider)? = nil, textProvider: any Lottie.AnimationTextProvider = DefaultTextProvider(), fontProvider: any Lottie.AnimationFontProvider = DefaultFontProvider())
  @_Concurrency.MainActor @preconcurrency @objc dynamic public init()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override final public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @objc deinit
}
extension Lottie.AnimationView {
  @_Concurrency.MainActor @preconcurrency convenience public init(name: Swift.String, bundle: Foundation.Bundle = Bundle.main, imageProvider: (any Lottie.AnimationImageProvider)? = nil, animationCache: (any Lottie.AnimationCacheProvider)? = LRUAnimationCache.sharedCache)
  @_Concurrency.MainActor @preconcurrency convenience public init(filePath: Swift.String, imageProvider: (any Lottie.AnimationImageProvider)? = nil, animationCache: (any Lottie.AnimationCacheProvider)? = LRUAnimationCache.sharedCache)
  @_Concurrency.MainActor @preconcurrency convenience public init(url: Foundation.URL, imageProvider: (any Lottie.AnimationImageProvider)? = nil, closure: @escaping Lottie.AnimationView.DownloadClosure, animationCache: (any Lottie.AnimationCacheProvider)? = LRUAnimationCache.sharedCache)
  public typealias DownloadClosure = ((any Swift.Error)?) -> Swift.Void
}
public protocol AnyValueProvider {
  var valueType: any Any.Type { get }
  func hasUpdate(frame: Lottie.AnimationFrameTime) -> Swift.Bool
  func value(frame: Lottie.AnimationFrameTime) -> Any
}
public class Asset : Swift.Codable {
  final public let id: Swift.String
  required public init(from decoder: any Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
}
public class BundleImageProvider : Lottie.AnimationImageProvider {
  public init(bundle: Foundation.Bundle, searchPath: Swift.String?)
  public func imageForAsset(asset: Lottie.ImageAsset) -> CoreGraphics.CGImage?
  @objc deinit
}
public enum ColorFormatDenominator {
  case One
  case OneHundred
  case TwoFiftyFive
  public static func == (a: Lottie.ColorFormatDenominator, b: Lottie.ColorFormatDenominator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct Color {
  public var r: Swift.Double
  public var g: Swift.Double
  public var b: Swift.Double
  public var a: Swift.Double
  public init(r: Swift.Double, g: Swift.Double, b: Swift.Double, a: Swift.Double, denominator: Lottie.ColorFormatDenominator = .One)
}
extension Lottie.Color : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
final public class ColorValueProvider : Lottie.AnyValueProvider {
  public typealias ColorValueBlock = (CoreFoundation.CGFloat) -> Lottie.Color
  final public var color: Lottie.Color {
    get
    set
  }
  public init(block: @escaping Lottie.ColorValueProvider.ColorValueBlock)
  public init(_ color: Lottie.Color)
  final public var valueType: any Any.Type {
    get
  }
  final public func hasUpdate(frame: CoreFoundation.CGFloat) -> Swift.Bool
  final public func value(frame: CoreFoundation.CGFloat) -> Any
  @objc deinit
}
@objc final public class CompatibleAnimationKeypath : ObjectiveC.NSObject {
  @objc public init(keypath: Swift.String)
  @objc public init(keys: [Swift.String])
  final public let animationKeypath: Lottie.AnimationKeypath
  @objc deinit
}
@objc final public class CompatibleAnimation : ObjectiveC.NSObject {
  @objc public init(name: Swift.String, bundle: Foundation.Bundle = Bundle.main)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc @_Concurrency.MainActor @preconcurrency final public class CompatibleAnimationView : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @objc @_Concurrency.MainActor @preconcurrency final public var compatibleAnimation: Lottie.CompatibleAnimation? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var loopAnimationCount: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override final public var contentMode: UIKit.UIView.ContentMode {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var shouldRasterizeWhenIdle: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var currentProgress: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var currentTime: Foundation.TimeInterval {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var currentFrame: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var realtimeAnimationFrame: CoreFoundation.CGFloat {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var realtimeAnimationProgress: CoreFoundation.CGFloat {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var animationSpeed: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var respectAnimationFrameRate: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var isAnimationPlaying: Swift.Bool {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency final public func play()
  @objc @_Concurrency.MainActor @preconcurrency final public func play(completion: ((Swift.Bool) -> Swift.Void)?)
  @objc @_Concurrency.MainActor @preconcurrency final public func play(fromProgress: CoreFoundation.CGFloat, toProgress: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor @preconcurrency final public func play(fromFrame: CoreFoundation.CGFloat, toFrame: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor @preconcurrency final public func play(fromMarker: Swift.String, toMarker: Swift.String, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor @preconcurrency final public func stop()
  @objc @_Concurrency.MainActor @preconcurrency final public func pause()
  @objc @_Concurrency.MainActor @preconcurrency final public func reloadImages()
  @objc @_Concurrency.MainActor @preconcurrency final public func forceDisplayUpdate()
  @objc @_Concurrency.MainActor @preconcurrency final public func getValue(for keypath: Lottie.CompatibleAnimationKeypath, atFrame: CoreFoundation.CGFloat) -> Any?
  @objc @_Concurrency.MainActor @preconcurrency final public func logHierarchyKeypaths()
  @objc @_Concurrency.MainActor @preconcurrency final public func setColorValue(_ color: UIKit.UIColor, forKeypath keypath: Lottie.CompatibleAnimationKeypath)
  @objc @_Concurrency.MainActor @preconcurrency final public func getColorValue(for keypath: Lottie.CompatibleAnimationKeypath, atFrame: CoreFoundation.CGFloat) -> UIKit.UIColor?
  @objc @_Concurrency.MainActor @preconcurrency final public func addSubview(_ subview: Lottie.AnimationSubview, forLayerAt keypath: Lottie.CompatibleAnimationKeypath)
  @objc @_Concurrency.MainActor @preconcurrency final public func convert(rect: CoreFoundation.CGRect, toLayerAt keypath: Lottie.CompatibleAnimationKeypath?) -> CoreFoundation.CGRect
  @objc @_Concurrency.MainActor @preconcurrency final public func convert(point: CoreFoundation.CGPoint, toLayerAt keypath: Lottie.CompatibleAnimationKeypath?) -> CoreFoundation.CGPoint
  @objc @_Concurrency.MainActor @preconcurrency final public func progressTime(forMarker named: Swift.String) -> CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency final public func frameTime(forMarker named: Swift.String) -> CoreFoundation.CGFloat
  @objc deinit
}
public class FilepathImageProvider : Lottie.AnimationImageProvider {
  public init(filepath: Swift.String)
  public init(filepath: Foundation.URL)
  public func imageForAsset(asset: Lottie.ImageAsset) -> CoreGraphics.CGImage?
  @objc deinit
}
final public class FloatValueProvider : Lottie.AnyValueProvider {
  public typealias CGFloatValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public var float: CoreFoundation.CGFloat {
    get
    set
  }
  public init(block: @escaping Lottie.FloatValueProvider.CGFloatValueBlock)
  public init(_ float: CoreFoundation.CGFloat)
  final public var valueType: any Any.Type {
    get
  }
  final public func hasUpdate(frame: CoreFoundation.CGFloat) -> Swift.Bool
  final public func value(frame: CoreFoundation.CGFloat) -> Any
  @objc deinit
}
final public class GradientValueProvider : Lottie.AnyValueProvider {
  public typealias ColorsValueBlock = (CoreFoundation.CGFloat) -> [Lottie.Color]
  public typealias ColorLocationsBlock = (CoreFoundation.CGFloat) -> [Swift.Double]
  final public var colors: [Lottie.Color] {
    get
    set
  }
  final public var locations: [Swift.Double] {
    get
    set
  }
  public init(block: @escaping Lottie.GradientValueProvider.ColorsValueBlock, locations: Lottie.GradientValueProvider.ColorLocationsBlock? = nil)
  public init(_ colors: [Lottie.Color], locations: [Swift.Double] = [])
  final public var valueType: any Any.Type {
    get
  }
  final public func hasUpdate(frame: CoreFoundation.CGFloat) -> Swift.Bool
  final public func value(frame: CoreFoundation.CGFloat) -> Any
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class ImageAsset : Lottie.Asset {
  final public let name: Swift.String
  final public let directory: Swift.String
  final public let width: Swift.Double
  final public let height: Swift.Double
  override final public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
extension QuartzCore.CALayer {
  public func logLayerTree(withIndent: Swift.Int = 0)
}
public enum LayerType : Swift.Int, Swift.Codable {
  case precomp
  case solid
  case image
  case null
  case shape
  case text
  public init(from decoder: any Swift.Decoder) throws
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum MatteType : Swift.Int, Swift.Codable {
  case none
  case add
  case invert
  case unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum BlendMode : Swift.Int, Swift.Codable {
  case normal
  case multiply
  case screen
  case overlay
  case darken
  case lighten
  case colorDodge
  case colorBurn
  case hardLight
  case softLight
  case difference
  case exclusion
  case hue
  case saturation
  case color
  case luminosity
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class LottieView : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func didMoveToWindow()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var contentMode: UIKit.UIView.ContentMode {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public class LRUAnimationCache : Lottie.AnimationCacheProvider {
  public init()
  public func clearCache()
  public static let sharedCache: Lottie.LRUAnimationCache
  public var cacheSize: Swift.Int
  public func animation(forKey: Swift.String) -> Lottie.Animation?
  public func setAnimation(_ animation: Lottie.Animation, forKey: Swift.String)
  @objc deinit
}
infix operator +| : DefaultPrecedence
infix operator +- : DefaultPrecedence
final public class PointValueProvider : Lottie.AnyValueProvider {
  public typealias PointValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGPoint
  final public var point: CoreFoundation.CGPoint {
    get
    set
  }
  public init(block: @escaping Lottie.PointValueProvider.PointValueBlock)
  public init(_ point: CoreFoundation.CGPoint)
  final public var valueType: any Any.Type {
    get
  }
  final public func hasUpdate(frame: CoreFoundation.CGFloat) -> Swift.Bool
  final public func value(frame: CoreFoundation.CGFloat) -> Any
  @objc deinit
}
final public class SizeValueProvider : Lottie.AnyValueProvider {
  public typealias SizeValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGSize
  final public var size: CoreFoundation.CGSize {
    get
    set
  }
  public init(block: @escaping Lottie.SizeValueProvider.SizeValueBlock)
  public init(_ size: CoreFoundation.CGSize)
  final public var valueType: any Any.Type {
    get
  }
  final public func hasUpdate(frame: CoreFoundation.CGFloat) -> Swift.Bool
  final public func value(frame: CoreFoundation.CGFloat) -> Any
  @objc deinit
}
extension UIKit.UIColor {
  public var lottieColorValue: Lottie.Color {
    get
  }
}
public struct Vector1D {
  public init(_ value: Swift.Double)
  public let value: Swift.Double
}
public struct Vector3D {
  public let x: Swift.Double
  public let y: Swift.Double
  public let z: Swift.Double
  public init(x: Swift.Double, y: Swift.Double, z: Swift.Double)
}
extension Lottie.Vector1D : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Lottie.Vector3D : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Lottie.Vector3D {
  public var pointValue: CoreFoundation.CGPoint {
    get
  }
  public var sizeValue: CoreFoundation.CGSize {
    get
  }
}
extension Lottie.AnimatedSwitch.CancelBehavior : Swift.Equatable {}
extension Lottie.AnimatedSwitch.CancelBehavior : Swift.Hashable {}
extension Lottie.CoordinateSpace : Swift.Equatable {}
extension Lottie.CoordinateSpace : Swift.Hashable {}
extension Lottie.CoordinateSpace : Swift.RawRepresentable {}
extension Lottie.LottieBackgroundBehavior : Swift.Equatable {}
extension Lottie.LottieBackgroundBehavior : Swift.Hashable {}
extension Lottie.ColorFormatDenominator : Swift.Equatable {}
extension Lottie.ColorFormatDenominator : Swift.Hashable {}
extension Lottie.LayerType : Swift.Equatable {}
extension Lottie.LayerType : Swift.Hashable {}
extension Lottie.LayerType : Swift.RawRepresentable {}
extension Lottie.MatteType : Swift.Equatable {}
extension Lottie.MatteType : Swift.Hashable {}
extension Lottie.MatteType : Swift.RawRepresentable {}
extension Lottie.BlendMode : Swift.Equatable {}
extension Lottie.BlendMode : Swift.Hashable {}
extension Lottie.BlendMode : Swift.RawRepresentable {}
